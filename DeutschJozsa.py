from qiskit import QuantumCircuit, transpile
from qiskit import Aer
from qiskit.visualization import plot_histogram
import matplotlib.pyplot as plt
import FunctionsJozsa as Fj

# Esta función se encarga de verificar si la función dada es balanceada o constante
def balanced_constant(counts):
    if '0000' in counts.keys():
        return "Constante"
    else:
        return "Balanceada"

# Ejecución del programa principal aplicando el algoritmo de Deutsch-Jozsa a cada una de las funciones que se encuentran en
# el archivo FunctionsJozsa.py
def Pruebas():
    result1 = Fj.Pruebas()
    result2 = []
    # Primera Función
    results = []
    print("Función Constante")
    simulator = Aer.get_backend('qasm_simulator')
    circuit = QuantumCircuit(5, 4)
    circuit.x(4)
    circuit.barrier()
    circuit.h(0)
    circuit.h(1)
    circuit.h(2)
    circuit.h(3)
    circuit.h(4)
    circuit.barrier()
    circuit.i(0)
    circuit.i(1)
    circuit.i(2)
    circuit.i(3)
    circuit.i(4)
    circuit.barrier()
    circuit.h(0)
    circuit.h(1)
    circuit.h(2)
    circuit.h(3)
    circuit.barrier()
    circuit.measure([0,1,2,3], [3,2,1,0])
    compiled_circuit = transpile(circuit, simulator)
    job = simulator.run(compiled_circuit, shots=1000)
    result = job.result()
    counts = result.get_counts(circuit)
    print(balanced_constant(counts))
    result2.append(balanced_constant(counts))
    print(circuit)
    plot_histogram(counts)
    plt.show()
    # Segunda Función
    print("Función Balanceada No 1")
    simulator = Aer.get_backend('qasm_simulator')
    circuit = QuantumCircuit(5, 4)
    circuit.x(4)
    circuit.barrier()
    circuit.h(0)
    circuit.h(1)
    circuit.h(2)
    circuit.h(3)
    circuit.h(4)
    circuit.barrier()
    circuit.cx(0, 4)
    circuit.barrier()
    circuit.h(0)
    circuit.h(1)
    circuit.h(2)
    circuit.h(3)
    circuit.barrier()
    circuit.measure([0,1,2,3], [3,2,1,0])
    compiled_circuit = transpile(circuit, simulator)
    job = simulator.run(compiled_circuit, shots=1000)
    result = job.result()
    counts = result.get_counts(circuit)
    print(balanced_constant(counts))
    result2.append(balanced_constant(counts))
    print(circuit)
    plot_histogram(counts)
    plt.show()
    # Tercera Función
    print("Función Balanceada No 2")
    simulator = Aer.get_backend('qasm_simulator')
    circuit = QuantumCircuit(5, 4)
    circuit.x(4)
    circuit.barrier()
    circuit.h(0)
    circuit.h(1)
    circuit.h(2)
    circuit.h(3)
    circuit.h(4)
    circuit.barrier()
    circuit.cx(1, 4)
    circuit.barrier()
    circuit.h(0)
    circuit.h(1)
    circuit.h(2)
    circuit.h(3)
    circuit.barrier()
    circuit.measure([0,1,2,3], [3,2,1,0])
    compiled_circuit = transpile(circuit, simulator)
    job = simulator.run(compiled_circuit, shots=1000)
    result = job.result()
    counts = result.get_counts(circuit)
    print(balanced_constant(counts))
    result2.append(balanced_constant(counts))
    print(circuit)
    plot_histogram(counts)
    plt.show()
    # Cuarta Función
    print("Función Balanceada No 3")
    simulator = Aer.get_backend('qasm_simulator')
    circuit = QuantumCircuit(5, 4)
    circuit.x(4)
    circuit.barrier()
    circuit.h(0)
    circuit.h(1)
    circuit.h(2)
    circuit.h(3)
    circuit.h(4)
    circuit.barrier()
    circuit.cx(2, 4)
    circuit.barrier()
    circuit.h(0)
    circuit.h(1)
    circuit.h(2)
    circuit.h(3)
    circuit.barrier()
    circuit.measure([0,1,2,3], [3,2,1,0])
    compiled_circuit = transpile(circuit, simulator)
    job = simulator.run(compiled_circuit, shots=1000)
    result = job.result()
    counts = result.get_counts(circuit)
    print(balanced_constant(counts))
    result2.append(balanced_constant(counts))
    print(circuit)
    plot_histogram(counts)
    plt.show()
    result1.extend(result2)
    return result1
